[{"content":"TEsT ","permalink":"https://www.xuechao.net/posts/20240709/","summary":"TEsT ","title":"20240709"},{"content":"","permalink":"https://www.xuechao.net/20240709/","summary":"","title":"20240709"},{"content":" This is a Blog for CFD, Simulation and Machine Learing .\nEmail: xuechao@gmail.com\n","permalink":"https://www.xuechao.net/about/","summary":"This is a Blog for CFD, Simulation and Machine Learing .\nEmail: xuechao@gmail.com","title":"About"},{"content":"摘要 本项目：\n设计了一个包含传热和对流两种物理现象的简单模型，该模型的形状尺寸参数和物理边界条件设置都可以在一定的范围内改变， 使用Star-CCM+的Design Manager功能进行sweep研究， 使用java编程和Design Manager的sweep功能，计算了183,750个算例， 将该模型的输入和输出数据保存成一个单独的数据集， 可以在后面的机器学习中进行试验， 最终通过对数据集进行机器学习，得到了一个神经网络模型，可以用来进行预测任意该模型在不同参数下的热表现。 验证了如果有足够的数据，就可以通过机器学习与工程应用结合进行研究，得出有价值的成果。 软硬件资源 软件：\nStar-CCM+ 3D-CAD Automation Design Manager Java Jupyter Notebook pandas numpy matplotlib pytorch 硬件：\nPC 6核以上CPU 8G RAM 独立显卡 模型 模型如下图所示：\n模型由3部分构成：\nheat plate air heat:发热体，材料属性设置为铜，与plate紧密连接在一起，之间没有热阻。其长宽高分别是尺寸变量。\nplate：不发热，材料属性设置为铁，其长宽为尺寸变量，其高度与heat保持一致。\nair：流体域，进口速度为变量，温度为恒定。\n该简单的模型主要描述的就是从heat这个部件发出一定的热量，大部分通过与plate接触传到到plate上面，然后经过plate与air的对流换热散发到air中去，heat还有较少部分热量通过heat顶面与air直接对流换热。\n该换热模型的变量一共有如下7个：\nH \u0026mdash;\u0026mdash;plate的宽，范围为[50,150]mm L \u0026mdash;\u0026mdash;plate的长，范围为[50,150]mm W \u0026mdash;\u0026mdash;plate的厚，范围为[5,20]mm H2 \u0026mdash;\u0026mdash;heat的宽，范围为[5,20]mm L2 \u0026mdash;\u0026mdash;heat的长，范围为[5,20]mm v_air \u0026mdash;\u0026mdash;空气的进口速度，范围为[5,20]m/s heat \u0026mdash;\u0026mdash;heat的发热量，范围为[1,20]w 数据集 该数据集可以在如下地址下载。\n该数据集的名称解释如下：\nDesign#\t：Star-CCM+中的设计编号 \u0026ldquo;Name\u0026rdquo;\t：Star-CCM+中的DM单次计算顺序 \u0026ldquo;T_d\u0026rdquo;\t：空气的进出口温差 \u0026ldquo;T_inlet (C)\u0026rdquo;\t：空气进口温度 \u0026ldquo;T_outlet (C)\u0026rdquo;\t：空气出口温度 \u0026ldquo;energy_out\u0026rdquo;\t：根据空气进出口温差计算的空气通过对流带走的热量 \u0026ldquo;heatT (C)\u0026rdquo;\t：heat的平均温度 \u0026ldquo;mass (kg/s)\u0026rdquo;\t：空气的质量流量 \u0026ldquo;Performance\u0026rdquo;\t：DM对单次设计的性能评价，我们只是通过Sweep功能来收集数据，该项没有意义。 \u0026ldquo;H (mm)\u0026rdquo;\t：plate的宽 \u0026ldquo;H2 (mm)\u0026rdquo;\t：heat的宽 \u0026ldquo;L (mm)\u0026rdquo;\t：plate的长 \u0026ldquo;L2 (mm)\u0026rdquo;\t：heat的长 \u0026ldquo;W (mm)\u0026rdquo;\t：plate的厚 \u0026ldquo;Wair (mm)\u0026rdquo;\t：为模型中air的高度，设置为常量 \u0026ldquo;heat\u0026rdquo;\t：heat的发热量 \u0026ldquo;v\u0026rdquo;：空气的进口速度 机器学习 将数据集导入notebook并且做一些处理，选取我们主要的输入和输出：\ndf.columns Index([\u0026#39;Design#\u0026#39;, \u0026#39;Name\u0026#39;, \u0026#39;T_d\u0026#39;, \u0026#39;T_inlet(C)\u0026#39;, \u0026#39;T_outlet(C)\u0026#39;, \u0026#39;energy_out\u0026#39;, \u0026#39;heatT(C)\u0026#39;, \u0026#39;mass(kg/s)\u0026#39;, \u0026#39;Performance\u0026#39;, \u0026#39;H(mm)\u0026#39;, \u0026#39;H2(mm)\u0026#39;, \u0026#39;L(mm)\u0026#39;, \u0026#39;L2(mm)\u0026#39;, \u0026#39;W(mm)\u0026#39;, \u0026#39;Wair(mm)\u0026#39;, \u0026#39;heat\u0026#39;, \u0026#39;v\u0026#39;], dtype=\u0026#39;object\u0026#39;) selected_columns = [ \u0026#39;H(mm)\u0026#39;, \u0026#39;H2(mm)\u0026#39;, \u0026#39;L(mm)\u0026#39;,\u0026#39;L2(mm)\u0026#39;, \u0026#39;W(mm)\u0026#39;, \u0026#39;heat\u0026#39;, \u0026#39;v\u0026#39;,\u0026#39;heatT(C)\u0026#39;] df =df[selected_columns] df.head() df.describe() 数据集数据之间的线性相关性如下图所示：\n使用SK-learn线性拟合： model=LinearRegression() model.fit(X_train,y_train) 测试集中，其预测值与实际值的对应关系如下：\n测试集的预测准确性评价如下：\nR2 score: 0.7899667696453285 Mean Squared Error: 104.53257228500799 Mean Absolute Error: 6.8060228938554435 使用神经网络进行学习： 神经网络模型主要采用了线性连接和ReLU激活函数。\n神界网络结构为1个输入层，7个隐藏层，1个输出层； 通过多个隐藏层，和每个隐藏层足够多的神经元，可以拟合比较复杂的物理现象； 通过使用ReLU激活函数，我们可以模拟传热和对流过程中的非线性现象。 def create_model_more_hidden_layers(num_input_cols,num_output_cols): model=nn.Sequential( nn.Linear(num_input_cols,10), nn.ReLU(), nn.Linear(10,50), nn.ReLU(), nn.Linear(50,100), nn.ReLU(), nn.Linear(100,100), nn.ReLU(), nn.Linear(100,100), nn.ReLU(), nn.Linear(100,100), nn.ReLU(), nn.Linear(100,50), nn.ReLU(), nn.Linear(50,10), nn.ReLU(), nn.Linear(10,num_output_cols) # Output Layer with 1 neuron ) return model num_input_cols = X_train.shape[1] num_output_cols=1 num_epochs=10000 learning_rate=0.0001 model= create_model_more_hidden_layers(num_input_cols,num_output_cols).to(device) train_test_model(model,X_train,y_train,X_test,y_test,num_epochs,learning_rate) 测试集中，其预测值与实际值的对应关系如下：\n测试集的预测准确性评价如下：\nR2 score: 0.9957430057650765 Mean Squared Error: 2.1337025 Mean Absolute Error: 1.0782065 结论 通过以上一个简单传热和对流模型的整个研究过程，可以看出，在采用神经网络进行机器学习可以训练出来很好的模型用于预测复杂的物理现象。\n虽然本项目使用的数据是通过大量的计算得到的，但是通过仿真获得大量数据进行机器学习也有以下重要意义：\n数据丰富性：仿真可以生成大量多样化的数据，这对于训练复杂的机器学习模型尤为重要，尤其是在实际数据稀缺或获取成本高的情况下。\n成本效益：相比于现实中收集数据的高昂成本，仿真数据的生成成本通常较低，而且可以在较短时间内生成大量数据。\n可控性：仿真环境下可以精确控制变量，方便研究特定条件对模型表现的影响，有助于模型的优化和验证。\n覆盖极端情况：仿真可以模拟现实中难以遇到的极端情况，为机器学习模型提供全面的训练数据，提高模型在各种情况下的表现。\n进一步的思考 已经验证了通过大量反应模型特征的数据进行机器学习行成整个闭环，我们可以利用任何我们积累的工程数据，通过机器学习来进行重新认识和解读，甚至可以训练机器模型用于新的优化设计计算。 这个简单的模型非常简单，整体网格量也非常少，计算这大约18万组数据消耗的时间大约2-3周。如果一个更为复杂的模型，网格量稍微多一点，单个case计算时间以十几分钟计的话，那么是不是不可能得到一个如此巨大的数据集？ ","permalink":"https://www.xuechao.net/posts/cfd-and-machine-learning-part-1-a-simple-model/","summary":"摘要 本项目：\n设计了一个包含传热和对流两种物理现象的简单模型，该模型的形状尺寸参数和物理边界条件设置都可以在一定的范围内改变， 使用Star-CCM+的Design Manager功能进行sweep研究， 使用java编程和Design Manager的sweep功能，计算了183,750个算例， 将该模型的输入和输出数据保存成一个单独的数据集， 可以在后面的机器学习中进行试验， 最终通过对数据集进行机器学习，得到了一个神经网络模型，可以用来进行预测任意该模型在不同参数下的热表现。 验证了如果有足够的数据，就可以通过机器学习与工程应用结合进行研究，得出有价值的成果。 软硬件资源 软件：\nStar-CCM+ 3D-CAD Automation Design Manager Java Jupyter Notebook pandas numpy matplotlib pytorch 硬件：\nPC 6核以上CPU 8G RAM 独立显卡 模型 模型如下图所示：\n模型由3部分构成：\nheat plate air heat:发热体，材料属性设置为铜，与plate紧密连接在一起，之间没有热阻。其长宽高分别是尺寸变量。\nplate：不发热，材料属性设置为铁，其长宽为尺寸变量，其高度与heat保持一致。\nair：流体域，进口速度为变量，温度为恒定。\n该简单的模型主要描述的就是从heat这个部件发出一定的热量，大部分通过与plate接触传到到plate上面，然后经过plate与air的对流换热散发到air中去，heat还有较少部分热量通过heat顶面与air直接对流换热。\n该换热模型的变量一共有如下7个：\nH \u0026mdash;\u0026mdash;plate的宽，范围为[50,150]mm L \u0026mdash;\u0026mdash;plate的长，范围为[50,150]mm W \u0026mdash;\u0026mdash;plate的厚，范围为[5,20]mm H2 \u0026mdash;\u0026mdash;heat的宽，范围为[5,20]mm L2 \u0026mdash;\u0026mdash;heat的长，范围为[5,20]mm v_air \u0026mdash;\u0026mdash;空气的进口速度，范围为[5,20]m/s heat \u0026mdash;\u0026mdash;heat的发热量，范围为[1,20]w 数据集 该数据集可以在如下地址下载。\n该数据集的名称解释如下：\nDesign#\t：Star-CCM+中的设计编号 \u0026ldquo;Name\u0026rdquo;\t：Star-CCM+中的DM单次计算顺序 \u0026ldquo;T_d\u0026rdquo;\t：空气的进出口温差 \u0026ldquo;T_inlet (C)\u0026rdquo;\t：空气进口温度 \u0026ldquo;T_outlet (C)\u0026rdquo;\t：空气出口温度 \u0026ldquo;energy_out\u0026rdquo;\t：根据空气进出口温差计算的空气通过对流带走的热量 \u0026ldquo;heatT (C)\u0026rdquo;\t：heat的平均温度 \u0026ldquo;mass (kg/s)\u0026rdquo;\t：空气的质量流量 \u0026ldquo;Performance\u0026rdquo;\t：DM对单次设计的性能评价，我们只是通过Sweep功能来收集数据，该项没有意义。 \u0026ldquo;H (mm)\u0026rdquo;\t：plate的宽 \u0026ldquo;H2 (mm)\u0026rdquo;\t：heat的宽 \u0026ldquo;L (mm)\u0026rdquo;\t：plate的长 \u0026ldquo;L2 (mm)\u0026rdquo;\t：heat的长 \u0026ldquo;W (mm)\u0026rdquo;\t：plate的厚 \u0026ldquo;Wair (mm)\u0026rdquo;\t：为模型中air的高度，设置为常量 \u0026ldquo;heat\u0026rdquo;\t：heat的发热量 \u0026ldquo;v\u0026rdquo;：空气的进口速度 机器学习 将数据集导入notebook并且做一些处理，选取我们主要的输入和输出：","title":"CFD与机器学习（1）一个简单的模型"},{"content":"Introduciton In the new version of Star-CCM+, a very useful feature called Design Manager has been added. It is mainly used for optimization and parametric sweep simulations.\nApplications The development and optimization of most engineering products involve systematic analysis of the parameters affecting their performance. Product performance is related to its primary operational characteristics, which typically refer to measurable quantities such as weight, dimensions, or resistance. Identifying key parameters and adjusting their values to improve product performance usually requires numerous design iterations.\nEach iteration either improves or worsens the product to some extent. However, every design provides valuable information on how to seek the ultimate goal among the infinite potential designs. This information also reflects the operating mechanism of the entire model. While each piece of information might be like a \u0026ldquo;blind man touching an elephant,\u0026rdquo; if enough information can be collected and machine learning methods are used, then although each blind person sees only a part of the elephant, from the perspective of all the information, this group of blind people can truly \u0026ldquo;see\u0026rdquo; what the elephant looks like.\nThe issue In the current version of Star-CCM+, when performing calculations using the sweep mode, if a single design manager is used to sweep a large number of cases, the overall computational efficiency decreases.\nFor example, consider the following sweep case with a total of 12 variables, each taking 3 values for the sweep. The overall computational load is 3^12 = 531,441, meaning over 531,000 calculations need to be completed! Assuming we have the time and hardware to run these, once this sweeeeeep starts, we observe a sharp decline in computational efficiency. This can be seen from the CPU usage, which indicates that the CPUs are not fully utilized.\nPossible reason: It could be due to Star-CCM+ itself. For instance, if fewer variables are chosen, such as running calculations for only 7 variables, the overall computation load is 3^7 = 2,187. In such cases, CPU utilization remains consistently high throughout, leading to significantly improved computational efficiency.\nCountermeasure Based on the earlier description, the strategy would be to divide a large computation set into several smaller sets. In this case, Java programming can be utilized. Use a Java program to iterate over several variables, while iterating over the remaining variables in Star-CCM+. Ensure that the overall computation load in the Design Manager does not exceed 3000. After each computation set is completed, save its result file as a separate CSV file, which can later be merged with the data files.\njava file ... public class java1 extends MdxMacro { double[] W = { 20.0, 25.0, 30.0}; double[] heat = { 10.0,15.0, 20.0 }; double[] v = { 10.0,15.0, 20.0 }; ... } private void execute0() { ... for (int i = 0; i \u0026lt; W.length; i++) { ... mdxStudyParameter_0.getBaselineQuantity().setValueAndUnits(W[i], units_0); for (int j = 0; j \u0026lt; heat.length; j++) { ... mdxStudyParameter_1.getBaselineQuantity().setValueAndUnits(heat[j], units_0); for (int k = 0; k \u0026lt; v.length; k++) { ... mdxStudyParameter_2.getBaselineQuantity().setValueAndUnits(v[k], units_0); ... Conclusion Due to Star-CCM+\u0026rsquo;s support for Java, integrating Java code with the Design Manager can significantly enhance computational efficiency. This integration allows for optimal utilization of time and hardware resources, while also generating extensive datasets for further research purposes.\n","permalink":"https://www.xuechao.net/posts/use-star-ccm-design-manager-for-parametric-sweep/","summary":"Introduciton In the new version of Star-CCM+, a very useful feature called Design Manager has been added. It is mainly used for optimization and parametric sweep simulations.\nApplications The development and optimization of most engineering products involve systematic analysis of the parameters affecting their performance. Product performance is related to its primary operational characteristics, which typically refer to measurable quantities such as weight, dimensions, or resistance. Identifying key parameters and adjusting their values to improve product performance usually requires numerous design iterations.","title":"Use Star-CCM+ Design Manager for parametric sweep simulations"},{"content":"介绍 在Star-CCM+的新的版本中增加了一个非常好用的功能————Design Manager。主要用来进行优化计算和扫描计算。\n应用场景 大多数工程产品的开发和优化的方法是对影响其产品性能的参数进行系统性的分析。产品的性能受其主要运行状态特性相关，通常指的是可测量的量，如重量、尺寸或阻力。识别关键参数并调整其数值以改进产品性能的过程通常需要大量的设计迭代。\n每次迭代都会使产品在某种程度上变得更好或更糟。但是，每个设计都提供了关于如何在无限多的潜在设计中寻找最终目标的宝贵信息。这些信息还是反映了整个模型的运行机理，有可能每个信息只是一个人的“盲人摸象”，但是如果能够收集到足够多的信息，使用机器学习的方法，虽然每个盲人看到的只是大象的一部分，从所有信息的角度来看，我们这一群盲人真正的能“看到”这个大象到底长得是什么样子。\n研究发现 在现有的Star-CCM+版本计算中，通过sweep模式进行计算，如果单个design manager来sweep的案例较多的话，整体的计算效率会降低。\n比如，如下一个sweep案例，一共12个变量，每个变量取3个值进行扫描，整体计算量为：3^12=531441,整体53万个计算要跑完！首先假定咱们也有时间和硬件来运行，当这个sweeeeeep跑上之后，发现计算效率急剧下降，通过cpu的占用可以看出来几乎没有跑满。\n可能的原因：有可能是Star-CCM+本身的原因。因为，如果选择更少的变量，比如只跑其中7个变量，那么整体运算量为：3^7=2187,这个时候从始至终cpu的占用可以非常高，整体计算效率可以很高。\n对策 根据前面的描述，那么我们只能将一个大的运算集分成若干个小的运算集进行，这个时候我们可以使用java编程。利用java程序，将其中若干个变量在java程序中进行迭代，剩下的变量在Star-CCM+中迭代。保证在Design manager中整体计算量不要超过3000，每个运算集完成后，其结果文件保存为单独的csv文件，后面将数据文件合并即可。\n参考java文件 ... public class java1 extends MdxMacro { double[] W = { 20.0, 25.0, 30.0}; double[] heat = { 10.0,15.0, 20.0 }; double[] v = { 10.0,15.0, 20.0 }; ... } private void execute0() { ... for (int i = 0; i \u0026lt; W.length; i++) { ... mdxStudyParameter_0.getBaselineQuantity().setValueAndUnits(W[i], units_0); for (int j = 0; j \u0026lt; heat.length; j++) { ... mdxStudyParameter_1.getBaselineQuantity().setValueAndUnits(heat[j], units_0); for (int k = 0; k \u0026lt; v.length; k++) { ... mdxStudyParameter_2.getBaselineQuantity().setValueAndUnits(v[k], units_0); ... 结论 由于Star-CCCM+对于java语言的支持，可以将java代码与Design Manager结合起来，最终既可以提高计算效率，充分利用时间和硬件资源，并且还可以得到非常多的数据集，用于接下来的研究。\n","permalink":"https://www.xuechao.net/posts/using-starccmp-design-manager-to-perform-sweep/","summary":"介绍 在Star-CCM+的新的版本中增加了一个非常好用的功能————Design Manager。主要用来进行优化计算和扫描计算。\n应用场景 大多数工程产品的开发和优化的方法是对影响其产品性能的参数进行系统性的分析。产品的性能受其主要运行状态特性相关，通常指的是可测量的量，如重量、尺寸或阻力。识别关键参数并调整其数值以改进产品性能的过程通常需要大量的设计迭代。\n每次迭代都会使产品在某种程度上变得更好或更糟。但是，每个设计都提供了关于如何在无限多的潜在设计中寻找最终目标的宝贵信息。这些信息还是反映了整个模型的运行机理，有可能每个信息只是一个人的“盲人摸象”，但是如果能够收集到足够多的信息，使用机器学习的方法，虽然每个盲人看到的只是大象的一部分，从所有信息的角度来看，我们这一群盲人真正的能“看到”这个大象到底长得是什么样子。\n研究发现 在现有的Star-CCM+版本计算中，通过sweep模式进行计算，如果单个design manager来sweep的案例较多的话，整体的计算效率会降低。\n比如，如下一个sweep案例，一共12个变量，每个变量取3个值进行扫描，整体计算量为：3^12=531441,整体53万个计算要跑完！首先假定咱们也有时间和硬件来运行，当这个sweeeeeep跑上之后，发现计算效率急剧下降，通过cpu的占用可以看出来几乎没有跑满。\n可能的原因：有可能是Star-CCM+本身的原因。因为，如果选择更少的变量，比如只跑其中7个变量，那么整体运算量为：3^7=2187,这个时候从始至终cpu的占用可以非常高，整体计算效率可以很高。\n对策 根据前面的描述，那么我们只能将一个大的运算集分成若干个小的运算集进行，这个时候我们可以使用java编程。利用java程序，将其中若干个变量在java程序中进行迭代，剩下的变量在Star-CCM+中迭代。保证在Design manager中整体计算量不要超过3000，每个运算集完成后，其结果文件保存为单独的csv文件，后面将数据文件合并即可。\n参考java文件 ... public class java1 extends MdxMacro { double[] W = { 20.0, 25.0, 30.0}; double[] heat = { 10.0,15.0, 20.0 }; double[] v = { 10.0,15.0, 20.0 }; ... } private void execute0() { ... for (int i = 0; i \u0026lt; W.length; i++) { ... mdxStudyParameter_0.getBaselineQuantity().setValueAndUnits(W[i], units_0); for (int j = 0; j \u0026lt; heat.","title":"利用Star-CCM+的Design Manager来进行扫描计算"}]